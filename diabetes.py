# -*- coding: utf-8 -*-
"""Diabetes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1scb9T9VLjhXgrtDYTtBhwfpUjM1g9U4M

# **Logistic Regression on Diabities data**
"""

#Importing necessary libraries
import numpy as np              #used to perform mathematical and logical operations on array
import pandas as pd             #used to Analyse the data
import matplotlib.pyplot as plt #used to visualize the data
import seaborn as sns           #Seaborn makes data visualization easy and it helps in feature selection, detecting patterns, and evaluating models.

#Load the Diabetes dataset
df2=pd.read_csv(r'C:\Users\arpit\Downloads\Diabetes\diabetes.csv')

df2

#Prints the statistical information about the dataset
df2.describe()

#Printing the columns and their data types
df2.info()

#prints the first 5 rows of the dataset
df2.head()

#prints the last 5 rows of the dataset
df2.tail()

#Checking the null values
df2.isnull().sum()

# assigning the features/independent column to the x variable
x=df2.drop('Outcome',axis=1)

# assigning the target/dependent column to the y variable
y=df2.Outcome

#prints the first 5 rows of x variable
x.head()

#prints the first 5 rows of the y variable
y.head()

fig, axes = plt.subplots(1, 2, figsize=(10, 5))
sns.heatmap(df2[df2['Outcome'] == 1].describe().T[['mean']], annot=True, cmap="Blues", ax=axes[0])
axes[0].set_title("Diabetes")
sns.heatmap(df2[df2['Outcome'] == 0].describe().T[['mean']], annot=True, cmap="Blues", ax=axes[1])
axes[1].set_title("Non-Diabetes")
plt.tight_layout()
plt.show()
#Left (Diabetes): Shows the average values for people with diabetes.
#Right (Non-Diabetes): Shows the average values for people without diabetes.


cor=df2.corr()
plt.figure(figsize=(12,12))
sns.heatmap(cor,annot=True,cmap='coolwarm')
plt.show()
#A heatmap with color-coded correlations:
#Dark red areas show strong negative correlations.
#Dark blue areas show strong positive correlations.
#Lighter areas indicate weaker relationships.
#This helps to identify trends and relationships between variables


# Import train_test_split to split dataset into training and testing sets
from sklearn.model_selection import train_test_split

# We train the model to learn from the training and testing data, where it adjusts its internal parameters
# to best predict the target variable
from sklearn.linear_model import LogisticRegression


#Scatter plots in the off-diagonal show how each pair of variables are related.
#This is a powerful way to explore patterns, clusters, and relationships in the dataset!
sns.pairplot(data=df2,hue='Outcome',diag_kind='kde')  #hue='Outcome',If Outcome = 1(Diabetes), the points will have one color,If Outcome = 0(Non-Diabetes), the points will have another color.
plt.show()

# Split the data into 80% training and 20% testing
xtrain, xtest, ytrain, ytest=train_test_split(x,y,test_size=0.2,random_state=80)

xtrain

ytrain

xtest

ytest

# Initialize the Logistic Regression model
LGR = LogisticRegression()
LGR

# Fit the model on scaled data
LGR.fit(xtrain,ytrain)

# Make predictions on the test data
pred=LGR.predict(xtest)
pred

# Calculate performance metrics on the training data
from sklearn.metrics import accuracy_score, precision_score

#Accuracy of the model on the testing data
ac = accuracy_score(ytest,pred)
ac

#Precision (positive predictive value) on the training data
precision_train = precision_score(ytest,pred)
precision_train

# Accuracy shows the proportion of correct predictions out of all predictions made.
# It's a measure of the overall performance of the model.
print(f"Training Accuracy: {ac}")

# Precision tells us how many of the predicted positive cases are actually positive.
print(f"Training Precision: {precision_train}")

"""Making"""

l=[1,126,60,0,0,30.1,2.349,79]       # the list is in 1D array, you can give values of any row from the csv file
a=np.array(l).reshape(1,-1)          # making the list as 2d array, (1,-1) to make the column items to row item then it becomes one single row
ans=LGR.predict(a)                   # make it as a single row
print(ans)

def diapt(preg,gluc,bp,st,ins,bmi,dpf,age):  #  
  a=np.array([[float(preg),float(gluc),float(bp),float(st),float(ins),float(bmi),float(dpf),float(age)]]).reshape(1,-1)
  ans=LGR.predict(a)                         # make it as a single row
  print(ans)
  if(int(ans[0])==0):
    return "Not a Diabetic"
  else:
    return "Diabetic"

#Gradio and gtts are installed in the termial()
#Gradio helps you to create interactive UI for your Machine Learning models
#gtts is used to convert written text into spoken audio
#importing gTTS from gtts
from gtts import gTTS                                #Google Text-to-Speech(gtts)
import os                                            #you can easily get the current working directory using the os

def dia(preg,glucose,bp,skin,ins,bmi,dpf,age):       #defining a function for the entering the values in user interface
 dg=diapt(preg,glucose,bp,skin,ins,bmi,dpf,age)      #assigning the function diapt to the variable dg 
 print(dg)                                           
 tts=gTTS(text=dg,lang='en')                         #dg contains the text that will be spoken, en=English
 audio_file="dg.mp3"                                 
 tts.save(audio_file)                                #Saves the generated speech to an MP3 file named "dg.mp3".
 os.system(f'start{audio_file}')
 return dg, audio_file


#importing gradio
import gradio as gr
iface=gr.Interface(    
    fn=dia,                                         #calling the function that is declared earlier
    inputs=[gr.Number(label='Enter Pregnancies'),gr.Number(label='Enter Glucose'),gr.Number(label='Enter BloodPressure'),gr.Number(label='Enter SkinThickness'),gr.Number(label='Enter Insulin'),gr.Number(label='Enter BMI'),gr.Number(label='DiabetesPedigreeFunction'),gr.Number(label='Age')],
    outputs=[gr.Text(),gr.Audio()],                 #displaying output in text form
    title="Diabetes Prediction"                     #title for the interface
)
iface.launch(share=True)                            #is a method used to activate and display the user interface (UI) you've created
